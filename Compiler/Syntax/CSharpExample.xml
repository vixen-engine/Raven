<?xml version="1.0" encoding="utf-8"?>

<Tree Root="SyntaxNode">
    <PredefinedNode Name="StructuredTriviaSyntax" Base="CSharpSyntaxNode"/>
    
    <!-- Type names -->
    <Node Name="OmittedTypeArgumentSyntax" Base="TypeSyntax">
        <Kind Name="OmittedTypeArgument"/>
        <Field Name="OmittedTypeArgumentToken" Type="SyntaxToken">
            <Kind Name="OmittedTypeArgumentToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the omitted type argument.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an OmittedTypeArgumentSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="RefTypeSyntax" Base="TypeSyntax">
        <TypeComment>
            <summary>The ref modifier of a method's return value or a local.</summary>
        </TypeComment>
        <Kind Name="RefType"/>
        <Field Name="RefKeyword" Type="SyntaxToken">
            <Kind Name="RefKeyword"/>
        </Field>
        <Field Name="ReadOnlyKeyword" Type="SyntaxToken" Optional="true">
            <Kind Name="ReadOnlyKeyword"/>
            <PropertyComment>
                <summary>Gets the optional "readonly" keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeSyntax"/>
    </Node>
    <Node Name="ScopedTypeSyntax" Base="TypeSyntax">
        <TypeComment>
            <summary>The 'scoped' modifier of a local.</summary>
        </TypeComment>
        <Kind Name="ScopedType"/>
        <Field Name="ScopedKeyword" Type="SyntaxToken">
            <Kind Name="ScopedKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeSyntax"/>
    </Node>
    
    <!-- Expressions -->
    <Node Name="TupleExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="TupleExpression"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the open parenthesis.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Arguments" Type="SeparatedSyntaxList&lt;ArgumentSyntax&gt;" MinCount="2">
            <PropertyComment>
                <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the close parenthesis.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for tuple expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a TupleExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="MemberAccessExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="SimpleMemberAccessExpression"/>
        <Kind Name="PointerMemberAccessExpression"/>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="DotToken"/>
            <Kind Name="MinusGreaterThanToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Name" Type="SimpleNameSyntax">
            <PropertyComment>
                <summary>SimpleNameSyntax node representing the member being accessed.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for member access expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a MemberAccessExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ConditionalAccessExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ConditionalAccessExpression"/>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="QuestionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the question mark.</summary>
            </PropertyComment>
        </Field>
        <Field Name="WhenNotNull" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for conditional access expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a ConditionalAccessExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ElementBindingExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ElementBindingExpression"/>
        <Field Name="ArgumentList" Type="BracketedArgumentListSyntax">
            <PropertyComment>
                <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for element binding expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ElementBindingExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="RangeExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="RangeExpression"/>
        <Field Name="LeftOperand" Type="ExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="DotDotToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the operator of the range expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="RightOperand" Type="ExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for a range expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an RangeExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ImplicitElementAccessSyntax" Base="ExpressionSyntax">
        <Kind Name="ImplicitElementAccess"/>
        <Field Name="ArgumentList" Type="BracketedArgumentListSyntax">
            <PropertyComment>
                <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for implicit element access expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ImplicitElementAccessSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="BinaryExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="AddExpression"/>
        <Kind Name="SubtractExpression"/>
        <Kind Name="MultiplyExpression"/>
        <Kind Name="DivideExpression"/>
        <Kind Name="ModuloExpression"/>
        <Kind Name="LeftShiftExpression"/>
        <Kind Name="RightShiftExpression"/>
        <Kind Name="UnsignedRightShiftExpression"/>
        <Kind Name="LogicalOrExpression"/>
        <Kind Name="LogicalAndExpression"/>
        <Kind Name="BitwiseOrExpression"/>
        <Kind Name="BitwiseAndExpression"/>
        <Kind Name="ExclusiveOrExpression"/>
        <Kind Name="EqualsExpression"/>
        <Kind Name="NotEqualsExpression"/>
        <Kind Name="LessThanExpression"/>
        <Kind Name="LessThanOrEqualExpression"/>
        <Kind Name="GreaterThanExpression"/>
        <Kind Name="GreaterThanOrEqualExpression"/>
        <Kind Name="IsExpression"/>
        <Kind Name="AsExpression"/>
        <Kind Name="CoalesceExpression"/>
        <Field Name="Left" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="PlusToken"/>
            <Kind Name="MinusToken"/>
            <Kind Name="AsteriskToken"/>
            <Kind Name="SlashToken"/>
            <Kind Name="PercentToken"/>
            <Kind Name="LessThanLessThanToken"/>
            <Kind Name="GreaterThanGreaterThanToken"/>
            <Kind Name="GreaterThanGreaterThanGreaterThanToken"/>
            <Kind Name="BarBarToken"/>
            <Kind Name="AmpersandAmpersandToken"/>
            <Kind Name="BarToken"/>
            <Kind Name="AmpersandToken"/>
            <Kind Name="CaretToken"/>
            <Kind Name="EqualsEqualsToken"/>
            <Kind Name="ExclamationEqualsToken"/>
            <Kind Name="LessThanToken"/>
            <Kind Name="LessThanEqualsToken"/>
            <Kind Name="GreaterThanToken"/>
            <Kind Name="GreaterThanEqualsToken"/>
            <Kind Name="IsKeyword"/>
            <Kind Name="AsKeyword"/>
            <Kind Name="QuestionQuestionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the operator of the binary expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Right" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents an expression that has a binary operator.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a BinaryExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="AssignmentExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="SimpleAssignmentExpression"/>
        <Kind Name="AddAssignmentExpression"/>
        <Kind Name="SubtractAssignmentExpression"/>
        <Kind Name="MultiplyAssignmentExpression"/>
        <Kind Name="DivideAssignmentExpression"/>
        <Kind Name="ModuloAssignmentExpression"/>
        <Kind Name="AndAssignmentExpression"/>
        <Kind Name="ExclusiveOrAssignmentExpression"/>
        <Kind Name="OrAssignmentExpression"/>
        <Kind Name="LeftShiftAssignmentExpression"/>
        <Kind Name="RightShiftAssignmentExpression"/>
        <Kind Name="UnsignedRightShiftAssignmentExpression"/>
        <Kind Name="CoalesceAssignmentExpression" />
        <Field Name="Left" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="EqualsToken"/>
            <Kind Name="PlusEqualsToken"/>
            <Kind Name="MinusEqualsToken"/>
            <Kind Name="AsteriskEqualsToken"/>
            <Kind Name="SlashEqualsToken"/>
            <Kind Name="PercentEqualsToken"/>
            <Kind Name="AmpersandEqualsToken"/>
            <Kind Name="CaretEqualsToken"/>
            <Kind Name="BarEqualsToken"/>
            <Kind Name="LessThanLessThanEqualsToken"/>
            <Kind Name="GreaterThanGreaterThanEqualsToken"/>
            <Kind Name="GreaterThanGreaterThanGreaterThanEqualsToken"/>
            <Kind Name="QuestionQuestionEqualsToken" />
            <PropertyComment>
                <summary>SyntaxToken representing the operator of the assignment expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Right" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents an expression that has an assignment operator.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an AssignmentExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ConditionalExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ConditionalExpression"/>
        <Field Name="Condition" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="QuestionToken" Type="SyntaxToken">
            <Kind Name="QuestionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the question mark.</summary>
            </PropertyComment>
        </Field>
        <Field Name="WhenTrue" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ColonToken" Type="SyntaxToken">
            <Kind Name="ColonToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the colon.</summary>
            </PropertyComment>
        </Field>
        <Field Name="WhenFalse" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a ConditionalExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="LiteralExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ArgListExpression"/>
        <Kind Name="NumericLiteralExpression"/>
        <Kind Name="StringLiteralExpression"/>
        <Kind Name="Utf8StringLiteralExpression"/>
        <Kind Name="CharacterLiteralExpression"/>
        <Kind Name="TrueLiteralExpression"/>
        <Kind Name="FalseLiteralExpression"/>
        <Kind Name="NullLiteralExpression"/>
        <Kind Name="DefaultLiteralExpression"/>
        <Field Name="Token" Type="SyntaxToken">
            <Kind Name="ArgListKeyword"/>
            <Kind Name="NumericLiteralToken"/>
            <Kind Name="StringLiteralToken"/>
            <Kind Name="Utf8StringLiteralToken"/>
            <Kind Name="MultiLineRawStringLiteralToken"/>
            <Kind Name="Utf8MultiLineRawStringLiteralToken"/>
            <Kind Name="SingleLineRawStringLiteralToken"/>
            <Kind Name="Utf8SingleLineRawStringLiteralToken"/>
            <Kind Name="CharacterLiteralToken"/>
            <Kind Name="TrueKeyword"/>
            <Kind Name="FalseKeyword"/>
            <Kind Name="NullKeyword"/>
            <Kind Name="DefaultKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a LiteralExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="MakeRefExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="MakeRefExpression"/>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="MakeRefKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the MakeRefKeyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing open parenthesis.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>Argument of the primary function.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing close parenthesis.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a MakeRefExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="RefTypeExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="RefTypeExpression"/>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="RefTypeKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the RefTypeKeyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing open parenthesis.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>Argument of the primary function.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing close parenthesis.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a RefTypeExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="RefValueExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="RefValueExpression"/>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="RefValueKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the RefValueKeyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing open parenthesis.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>Typed reference expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Comma" Type="SyntaxToken">
            <Kind Name="CommaToken"/>
            <PropertyComment>
                <summary>Comma separating the arguments.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeSyntax">
            <PropertyComment>
                <summary>The type of the value.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing close parenthesis.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a RefValueExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="InvocationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="InvocationExpression"/>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="ArgumentListSyntax">
            <PropertyComment>
                <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an InvocationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ElementAccessExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ElementAccessExpression"/>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="BracketedArgumentListSyntax">
            <PropertyComment>
                <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for element access expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ElementAccessExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="DeclarationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="DeclarationExpression"/>
        <Field Name="Type" Type="TypeSyntax"/>
        <Field Name="Designation" Type="VariableDesignationSyntax">
            <PropertyComment>
                <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a DeclarationExpression node.</summary>
        </FactoryComment>
    </Node>

    <AbstractNode Name="AnonymousFunctionExpressionSyntax" Base="ExpressionSyntax">
        <TypeComment>
            <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
        </TypeComment>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <Choice>
            <Field Name="Block" Type="BlockSyntax">
                <PropertyComment>
                    <summary>
                        BlockSyntax node representing the body of the anonymous function.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
            <Field Name="ExpressionBody" Type="ExpressionSyntax">
                <PropertyComment>
                    <summary>
                        ExpressionSyntax node representing the body of the anonymous function.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
        </Choice>
    </AbstractNode>
    <Node Name="AnonymousMethodExpressionSyntax" Base="AnonymousFunctionExpressionSyntax" SkipConvenienceFactories="true">
        <Kind Name="AnonymousMethodExpression"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="DelegateKeyword" Type="SyntaxToken">
            <Kind Name="DelegateKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the delegate keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true">
            <PropertyComment>
                <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Block" Type="BlockSyntax" Override="true">
            <PropertyComment>
                <summary>
                    BlockSyntax node representing the body of the anonymous function.
                    This will never be null.
                </summary>
            </PropertyComment>
        </Field>
        <Field Name="ExpressionBody" Type="ExpressionSyntax" Optional="true" Override="true">
            <PropertyComment>
                <summary>
                    Inherited from AnonymousFunctionExpressionSyntax, but not used for
                    AnonymousMethodExpressionSyntax.  This will always be null.
                </summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an AnonymousMethodExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <AbstractNode Name="LambdaExpressionSyntax" Base="AnonymousFunctionExpressionSyntax">
        <TypeComment>
            <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
        </TypeComment>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;"/>
        <Field Name="ArrowToken" Type="SyntaxToken">
            <!-- should be EqualsGreaterThanToken -->
            <Kind Name="EqualsGreaterThanToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing equals greater than.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>
    <Node Name="SimpleLambdaExpressionSyntax" Base="LambdaExpressionSyntax">
        <Kind Name="SimpleLambdaExpression"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Parameter" Type="ParameterSyntax">
            <Kind Name="Parameter"/>
            <PropertyComment>
                <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArrowToken" Type="SyntaxToken" Override="true">
            <!-- should be EqualsGreaterThanToken -->
            <Kind Name="EqualsGreaterThanToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing equals greater than.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Block" Type="BlockSyntax" Override="true">
                <PropertyComment>
                    <summary>
                        BlockSyntax node representing the body of the lambda.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
            <Field Name="ExpressionBody" Type="ExpressionSyntax" Override="true">
                <PropertyComment>
                    <summary>
                        ExpressionSyntax node representing the body of the lambda.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
        </Choice>
        <TypeComment>
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a SimpleLambdaExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="RefExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="RefExpression"/>
        <Field Name="RefKeyword" Type="SyntaxToken">
            <Kind Name="RefKeyword"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="ParenthesizedLambdaExpressionSyntax" Base="LambdaExpressionSyntax">
        <Kind Name="ParenthesizedLambdaExpression"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="ReturnType" Type="TypeSyntax" Optional="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax">
            <PropertyComment>
                <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArrowToken" Type="SyntaxToken" Override="true">
            <!-- should be EqualsGreaterThanToken -->
            <Kind Name="EqualsGreaterThanToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing equals greater than.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Block" Type="BlockSyntax" Override="true">
                <PropertyComment>
                    <summary>
                        BlockSyntax node representing the body of the lambda.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
            <Field Name="ExpressionBody" Type="ExpressionSyntax" Override="true">
                <PropertyComment>
                    <summary>
                        ExpressionSyntax node representing the body of the lambda.
                        Only one of Block or ExpressionBody will be non-null.
                    </summary>
                </PropertyComment>
            </Field>
        </Choice>
        <TypeComment>
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a ParenthesizedLambdaExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="InitializerExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ObjectInitializerExpression"/>
        <Kind Name="CollectionInitializerExpression"/>
        <Kind Name="ArrayInitializerExpression"/>
        <Kind Name="ComplexElementInitializerExpression"/>
        <Kind Name="WithInitializerExpression" />
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the open brace.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Expressions" Type="SeparatedSyntaxList&lt;ExpressionSyntax&gt;" AllowTrailingSeparator="true">
            <PropertyComment>
                <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the close brace.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an InitializerExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <AbstractNode Name="BaseObjectCreationExpressionSyntax" Base="ExpressionSyntax">
        <Field Name="NewKeyword" Type="SyntaxToken">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="ArgumentListSyntax" Optional="true">
            <PropertyComment>
                <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>
    <Node Name="ImplicitObjectCreationExpressionSyntax" Base="BaseObjectCreationExpressionSyntax">
        <Kind Name="ImplicitObjectCreationExpression"/>
        <Field Name="NewKeyword" Type="SyntaxToken" Override="true">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="ArgumentListSyntax" Optional="false" Override="true">
            <PropertyComment>
                <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax" Optional="true" Override="true">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for implicit object creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ImplicitObjectCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ObjectCreationExpressionSyntax" Base="BaseObjectCreationExpressionSyntax">
        <Kind Name="ObjectCreationExpression"/>
        <Field Name="NewKeyword" Type="SyntaxToken" Override="true">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeSyntax">
            <PropertyComment>
                <summary>TypeSyntax representing the type of the object being created.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="ArgumentListSyntax" Optional="true" Override="true">
            <PropertyComment>
                <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax" Optional="true" Override="true">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ObjectCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="WithExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="WithExpression"/>
        <Field Name="Expression" Type="ExpressionSyntax" />
        <Field Name="WithKeyword" Type="SyntaxToken">
            <Kind Name="WithKeyword" />
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression for the with expression.</summary>
            </PropertyComment>
        </Field>
    </Node>

    <Node Name="AnonymousObjectCreationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="AnonymousObjectCreationExpression"/>
        <Field Name="NewKeyword" Type="SyntaxToken">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the open brace.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializers" Type="SeparatedSyntaxList&lt;AnonymousObjectMemberDeclaratorSyntax&gt;" AllowTrailingSeparator="true">
            <PropertyComment>
                <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the close brace.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an AnonymousObjectCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ArrayCreationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ArrayCreationExpression"/>
        <Field Name="NewKeyword" Type="SyntaxToken">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="ArrayTypeSyntax">
            <PropertyComment>
                <summary>ArrayTypeSyntax node representing the type of the array.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ArrayCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ImplicitArrayCreationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ImplicitArrayCreationExpression"/>
        <Field Name="NewKeyword" Type="SyntaxToken">
            <Kind Name="NewKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the new keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the open bracket.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Commas" Type="SyntaxList&lt;SyntaxToken&gt;">
            <PropertyComment>
                <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the close bracket.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ImplicitArrayCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="StackAllocArrayCreationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="StackAllocArrayCreationExpression"/>
        <Field Name="StackAllocKeyword" Type="SyntaxToken">
            <Kind Name="StackAllocKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the stackalloc keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeSyntax">
            <PropertyComment>
                <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a StackAllocArrayCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ImplicitStackAllocArrayCreationExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="ImplicitStackAllocArrayCreationExpression"/>
        <Field Name="StackAllocKeyword" Type="SyntaxToken">
            <Kind Name="StackAllocKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the stackalloc keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the open bracket.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the close bracket.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Initializer" Type="InitializerExpressionSyntax">
            <PropertyComment>
                <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ImplicitStackAllocArrayCreationExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="CollectionExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="CollectionExpression"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
        </Field>
        <Field Name="Elements" Type="SeparatedSyntaxList&lt;CollectionElementSyntax&gt;" AllowTrailingSeparator="true">
            <PropertyComment>
                <summary>SeparatedSyntaxList of CollectionElementSyntax representing the list of elements in the collection expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
        </Field>
    </Node>
    <AbstractNode Name="QueryClauseSyntax" Base="CSharpSyntaxNode">
    </AbstractNode>
    <AbstractNode Name="SelectOrGroupClauseSyntax" Base="CSharpSyntaxNode">
    </AbstractNode>
    <Node Name="QueryExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="QueryExpression"/>
        <Field Name="FromClause" Type="FromClauseSyntax"/>
        <Field Name="Body" Type="QueryBodySyntax"/>
    </Node>
    <Node Name="QueryBodySyntax" Base="CSharpSyntaxNode">
        <Kind Name="QueryBody"/>
        <Field Name="Clauses" Type="SyntaxList&lt;QueryClauseSyntax&gt;" MinCount="1"/>
        <Field Name="SelectOrGroup" Type="SelectOrGroupClauseSyntax"/>
        <Field Name="Continuation" Type="QueryContinuationSyntax" Optional="true"/>
    </Node>
    <Node Name="FromClauseSyntax" Base="QueryClauseSyntax">
        <Kind Name="FromClause"/>
        <Field Name="FromKeyword" Type="SyntaxToken">
            <Kind Name="FromKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeSyntax" Optional="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="InKeyword" Type="SyntaxToken">
            <Kind Name="InKeyword"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="LetClauseSyntax" Base="QueryClauseSyntax">
        <Kind Name="LetClause"/>
        <Field Name="LetKeyword" Type="SyntaxToken">
            <Kind Name="LetKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="EqualsToken" Type="SyntaxToken">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="JoinClauseSyntax" Base="QueryClauseSyntax">
        <Kind Name="JoinClause"/>
        <Field Name="JoinKeyword" Type="SyntaxToken">
            <Kind Name="JoinKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeSyntax" Optional="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="InKeyword" Type="SyntaxToken">
            <Kind Name="InKeyword"/>
        </Field>
        <Field Name="InExpression" Type="ExpressionSyntax"/>
        <Field Name="OnKeyword" Type="SyntaxToken">
            <Kind Name="OnKeyword"/>
        </Field>
        <Field Name="LeftExpression" Type="ExpressionSyntax"/>
        <Field Name="EqualsKeyword" Type="SyntaxToken">
            <Kind Name="EqualsKeyword"/>
        </Field>
        <Field Name="RightExpression" Type="ExpressionSyntax"/>
        <Field Name="Into" Type="JoinIntoClauseSyntax" Optional="true"/>
    </Node>
    <Node Name="JoinIntoClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="JoinIntoClause"/>
        <Field Name="IntoKeyword" Type="SyntaxToken">
            <Kind Name="IntoKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
    </Node>
    <Node Name="WhereClauseSyntax" Base="QueryClauseSyntax">
        <Kind Name="WhereClause"/>
        <Field Name="WhereKeyword" Type="SyntaxToken">
            <Kind Name="WhereKeyword"/>
        </Field>
        <Field Name="Condition" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="OrderByClauseSyntax" Base="QueryClauseSyntax">
        <Kind Name="OrderByClause"/>
        <Field Name="OrderByKeyword" Type="SyntaxToken">
            <Kind Name="OrderByKeyword"/>
        </Field>
        <Field Name="Orderings" Type="SeparatedSyntaxList&lt;OrderingSyntax&gt;" MinCount="1"/>
    </Node>
    <Node Name="OrderingSyntax" Base="CSharpSyntaxNode">
        <Kind Name="AscendingOrdering"/>
        <Kind Name="DescendingOrdering"/>
        <Field Name="Expression" Type="ExpressionSyntax"/>
        <Field Name="AscendingOrDescendingKeyword" Type="SyntaxToken" Optional="true">
            <Kind Name="AscendingKeyword"/>
            <Kind Name="DescendingKeyword"/>
        </Field>
    </Node>
    <Node Name="SelectClauseSyntax" Base="SelectOrGroupClauseSyntax">
        <Kind Name="SelectClause"/>
        <Field Name="SelectKeyword" Type="SyntaxToken">
            <Kind Name="SelectKeyword"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="GroupClauseSyntax" Base="SelectOrGroupClauseSyntax">
        <Kind Name="GroupClause"/>
        <Field Name="GroupKeyword" Type="SyntaxToken">
            <Kind Name="GroupKeyword"/>
        </Field>
        <Field Name="GroupExpression" Type="ExpressionSyntax"/>
        <Field Name="ByKeyword" Type="SyntaxToken">
            <Kind Name="ByKeyword"/>
        </Field>
        <Field Name="ByExpression" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="QueryContinuationSyntax" Base="CSharpSyntaxNode">
        <Kind Name="QueryContinuation"/>
        <Field Name="IntoKeyword" Type="SyntaxToken">
            <Kind Name="IntoKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="Body" Type="QueryBodySyntax"/>
    </Node>
    <Node Name="OmittedArraySizeExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="OmittedArraySizeExpression"/>
        <Field Name="OmittedArraySizeExpressionToken" Type="SyntaxToken">
            <Kind Name="OmittedArraySizeExpressionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the omitted array size expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents a placeholder in an array size list.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an OmittedArraySizeExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="InterpolatedStringExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="InterpolatedStringExpression"/>
        <Field Name="StringStartToken" Type="SyntaxToken">
            <Kind Name="InterpolatedStringStartToken"/>
            <Kind Name="InterpolatedVerbatimStringStartToken"/>
            <Kind Name="InterpolatedSingleLineRawStringStartToken"/>
            <Kind Name="InterpolatedMultiLineRawStringStartToken"/>
            <PropertyComment>
                <summary>The first part of an interpolated string, <c>$"</c> or <c>$@"</c> or <c>$"""</c></summary>
            </PropertyComment>
        </Field>
        <Field Name="Contents" Type="SyntaxList&lt;InterpolatedStringContentSyntax&gt;" >
            <PropertyComment>
                <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
            </PropertyComment>
        </Field>
        <Field Name="StringEndToken" Type="SyntaxToken">
            <Kind Name="InterpolatedStringEndToken"/>
            <Kind Name="InterpolatedStringEndToken"/>
            <Kind Name="InterpolatedRawStringEndToken"/>
            <Kind Name="InterpolatedRawStringEndToken"/>
            <PropertyComment>
                <summary>The closing quote of the interpolated string.</summary>
            </PropertyComment>
        </Field>
    </Node>


    <Node Name="DeclarationPatternSyntax" Base="PatternSyntax">
        <Kind Name="DeclarationPattern" />
        <Field Name="Type" Type="TypeSyntax"/>
        <Field Name="Designation" Type="VariableDesignationSyntax">
            <Kind Name="SingleVariableDesignation"/>
            <Kind Name="DiscardDesignation"/>
        </Field>
    </Node>

    <Node Name="RecursivePatternSyntax" Base="PatternSyntax">
        <Kind Name="RecursivePattern" />
        <Field Name="Type" Type="TypeSyntax" Optional="true" />
        <Field Name="PositionalPatternClause" Type="PositionalPatternClauseSyntax" Optional="true" />
        <Field Name="PropertyPatternClause" Type="PropertyPatternClauseSyntax" Optional="true" />
        <Field Name="Designation" Type="VariableDesignationSyntax" Optional="true">
            <Kind Name="SingleVariableDesignation"/>
            <Kind Name="DiscardDesignation"/>
        </Field>
    </Node>
    <Node Name="PositionalPatternClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="PositionalPatternClause"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Subpatterns" Type="SeparatedSyntaxList&lt;SubpatternSyntax&gt;"/>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="PropertyPatternClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="PropertyPatternClause"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Subpatterns" Type="SeparatedSyntaxList&lt;SubpatternSyntax&gt;" AllowTrailingSeparator="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
        </Field>
    </Node>
    <Node Name="SubpatternSyntax" Base="CSharpSyntaxNode">
        <Kind Name="Subpattern"/>
        <Field Name="ExpressionColon" Type="BaseExpressionColonSyntax" Optional="true"/>
        <Field Name="Pattern" Type="PatternSyntax" />
    </Node>
    <Node Name="ConstantPatternSyntax" Base="PatternSyntax">
        <Kind Name="ConstantPattern"/>
        <Field Name="Expression" Type="ExpressionSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the constant expression.</summary>
            </PropertyComment>
        </Field>
    </Node>

    <!-- Pattern forms added for C# 9.0 -->
    <Node Name="ParenthesizedPatternSyntax" Base="PatternSyntax">
        <Kind Name="ParenthesizedPattern"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Pattern" Type="PatternSyntax" />
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="BinaryPatternSyntax" Base="PatternSyntax">
        <Kind Name="OrPattern"/>
        <Kind Name="AndPattern"/>
        <Field Name="Left" Type="PatternSyntax" />
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="OrKeyword"/>
            <Kind Name="AndKeyword"/>
        </Field>
        <Field Name="Right" Type="PatternSyntax" />
    </Node>
    <Node Name="ListPatternSyntax" Base="PatternSyntax">
        <Kind Name="ListPattern"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
        </Field>
        <Field Name="Patterns" Type="SeparatedSyntaxList&lt;PatternSyntax&gt;" AllowTrailingSeparator="true"/>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
        </Field>
        <Field Name="Designation" Type="VariableDesignationSyntax" Optional="true">
            <Kind Name="SingleVariableDesignation"/>
            <Kind Name="DiscardDesignation"/>
        </Field>
    </Node>
    <Node Name="SlicePatternSyntax" Base="PatternSyntax">
        <Kind Name="SlicePattern"/>
        <Field Name="DotDotToken" Type="SyntaxToken">
            <Kind Name="DotDotToken"/>
        </Field>
        <Field Name="Pattern" Type="PatternSyntax" Optional="true"/>
    </Node>
    <AbstractNode Name="InterpolatedStringContentSyntax" Base="CSharpSyntaxNode" />
    <Node Name="InterpolatedStringTextSyntax" Base="InterpolatedStringContentSyntax">
        <Kind Name="InterpolatedStringText"/>
        <Field Name="TextToken" Type="SyntaxToken">
            <Kind Name="InterpolatedStringTextToken"/>
            <PropertyComment>
                <summary>The text contents of a part of the interpolated string.</summary>
            </PropertyComment>
        </Field>
    </Node>
    <Node Name="InterpolationSyntax" Base="InterpolatedStringContentSyntax">
        <Kind Name="Interpolation"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
            <PropertyComment>
                <summary>This could be a single <c>{</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).</summary>
            </PropertyComment>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
        <Field Name="AlignmentClause" Type="InterpolationAlignmentClauseSyntax" Optional="true"/>
        <Field Name="FormatClause" Type="InterpolationFormatClauseSyntax" Optional="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
            <PropertyComment>
                <summary>
                    This could be a single <c>}</c> or multiple in a row (in the case of an interpolation in a raw interpolated string).
                </summary>
            </PropertyComment>
        </Field>
    </Node>
    <Node Name="InterpolationAlignmentClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="InterpolationAlignmentClause"/>
        <Field Name="CommaToken" Type="SyntaxToken"/>
        <Field Name="Value" Type="ExpressionSyntax"/>
    </Node>
    <Node Name="InterpolationFormatClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="InterpolationFormatClause"/>
        <Field Name="ColonToken" Type="SyntaxToken"/>
        <Field Name="FormatStringToken" Type="SyntaxToken">
            <Kind Name="InterpolatedStringTextToken"/>
            <PropertyComment>
                <summary>The text contents of the format specifier for an interpolation.</summary>
            </PropertyComment>
        </Field>
    </Node>
    
    <!-- Statements -->
    <Node Name="GlobalStatementSyntax" Base="MemberDeclarationSyntax">
        <Kind Name="GlobalStatement"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true">
            <summary>Always empty on a global statement.</summary>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true">
            <summary>Always empty on a global statement.</summary>
        </Field>
        <Field Name="Statement" Type="StatementSyntax"/>
    </Node>
    <Node Name="SingleVariableDesignationSyntax" Base="VariableDesignationSyntax">
        <Kind Name="SingleVariableDesignation"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <Kind Name="IdentifierToken"/>
        </Field>
    </Node>

    <Node Name="ParenthesizedVariableDesignationSyntax" Base="VariableDesignationSyntax">
        <Kind Name="ParenthesizedVariableDesignation"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Variables" Type="SeparatedSyntaxList&lt;VariableDesignationSyntax&gt;"/>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="LabeledStatementSyntax" Base="StatementSyntax">
        <Kind Name="LabeledStatement"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="ColonToken" Type="SyntaxToken">
            <Kind Name="ColonToken"/>
            <PropertyComment>
                <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Statement" Type="StatementSyntax"/>
        <TypeComment>
            <summary>Represents a labeled statement syntax.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a LabeledStatementSyntax node</summary>
        </FactoryComment>
    </Node>
    <Node Name="GotoStatementSyntax" Base="StatementSyntax">
        <Kind Name="GotoStatement"/>
        <Kind Name="GotoCaseStatement"/>
        <Kind Name="GotoDefaultStatement"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="GotoKeyword" Type="SyntaxToken">
            <Kind Name="GotoKeyword"/>
            <PropertyComment>
                <summary>
                    Gets a SyntaxToken that represents the goto keyword.
                </summary>
            </PropertyComment>
        </Field>
        <Field Name="CaseOrDefaultKeyword" Type="SyntaxToken" Optional="true">
            <Kind Name="CaseKeyword"/>
            <Kind Name="DefaultKeyword"/>
            <PropertyComment>
                <summary>
                    Gets a SyntaxToken that represents the case or default keywords if any exists.
                </summary>
            </PropertyComment>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax" Optional="true">
            <PropertyComment>
                <summary>
                    Gets a constant expression for a goto case statement.
                </summary>
            </PropertyComment>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken">
            <Kind Name="SemicolonToken"/>
            <PropertyComment>
                <summary>
                    Gets a SyntaxToken that represents the semi-colon at the end of the statement.
                </summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>
                Represents a goto statement syntax
            </summary>
        </TypeComment>
        <FactoryComment>
            <summary>
                Creates a GotoStatementSyntax node.
            </summary>
        </FactoryComment>
    </Node>
    <Node Name="YieldStatementSyntax" Base="StatementSyntax">
        <Kind Name="YieldReturnStatement"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Kind Name="YieldBreakStatement"/>
        <Field Name="YieldKeyword" Type="SyntaxToken">
            <Kind Name="YieldKeyword"/>
        </Field>
        <Field Name="ReturnOrBreakKeyword" Type="SyntaxToken">
            <Kind Name="ReturnKeyword"/>
            <Kind Name="BreakKeyword"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax" Optional="true"/>
        <Field Name="SemicolonToken" Type="SyntaxToken">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="LockStatementSyntax" Base="StatementSyntax">
        <Kind Name="LockStatement"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="LockKeyword" Type="SyntaxToken">
            <Kind Name="LockKeyword"/>
        </Field>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
        </Field>
        <Field Name="Statement" Type="StatementSyntax"/>
    </Node>
    <Node Name="SwitchExpressionSyntax" Base="ExpressionSyntax">
        <Kind Name="SwitchExpression"/>
        <Field Name="GoverningExpression" Type="ExpressionSyntax"/>
        <Field Name="SwitchKeyword" Type="SyntaxToken">
            <Kind Name="SwitchKeyword"/>
        </Field>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Arms" Type="SeparatedSyntaxList&lt;SwitchExpressionArmSyntax&gt;" AllowTrailingSeparator="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
        </Field>
    </Node>
    <Node Name="SwitchExpressionArmSyntax" Base="CSharpSyntaxNode">
        <Kind Name="SwitchExpressionArm"/>
        <Field Name="Pattern" Type="PatternSyntax"/>
        <Field Name="WhenClause" Type="WhenClauseSyntax" Optional="true"/>
        <Field Name="EqualsGreaterThanToken" Type="SyntaxToken">
            <Kind Name="EqualsGreaterThanToken"/>
        </Field>
        <Field Name="Expression" Type="ExpressionSyntax"/>
    </Node>

    <!-- Declarations -->
    <Node Name="CompilationUnitSyntax" Base="CSharpSyntaxNode">
        <Kind Name="CompilationUnit"/>
        <Field Name="Externs" Type="SyntaxList&lt;ExternAliasDirectiveSyntax&gt;"/>
        <Field Name="Usings" Type="SyntaxList&lt;UsingDirectiveSyntax&gt;"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;"/>
        <Field Name="EndOfFileToken" Type="SyntaxToken">
            <Kind Name="EndOfFileToken"/>
        </Field>
    </Node>
    <Node Name="ExternAliasDirectiveSyntax" Base="CSharpSyntaxNode">
        <Kind Name="ExternAliasDirective"/>
        <Field Name="ExternKeyword" Type="SyntaxToken">
            <Kind Name="ExternKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the extern keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="AliasKeyword" Type="SyntaxToken">
            <Kind Name="AliasKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken representing the alias keyword.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken">
            <Kind Name="SemicolonToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the semicolon token.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>
                Represents an ExternAlias directive syntax, e.g. &quot;extern alias MyAlias;&quot; with specifying &quot;/r:MyAlias=SomeAssembly.dll &quot; on the compiler command line.
            </summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ExternAliasDirectiveSyntax node</summary>
        </FactoryComment>
    </Node>
    <AbstractNode Name="BaseTypeDeclarationSyntax" Base="MemberDeclarationSyntax">
        <TypeComment>
            <summary>Base class for type declaration syntax.</summary>
        </TypeComment>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true">
            <PropertyComment>
                <summary>Gets the base type list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Optional="true">
            <PropertyComment>
                <summary>Gets the open brace token.</summary>
            </PropertyComment>
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Optional="true">
            <PropertyComment>
                <summary>Gets the close brace token.</summary>
            </PropertyComment>
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true">
            <PropertyComment>
                <summary>Gets the optional semicolon token.</summary>
            </PropertyComment>
            <Kind Name="SemicolonToken"/>
        </Field>
    </AbstractNode>
    <AbstractNode Name="TypeDeclarationSyntax" Base="BaseTypeDeclarationSyntax">
        <TypeComment>
            <summary>Base class for type declaration syntax (class, struct, interface, record).</summary>
        </TypeComment>
        <Field Name="Keyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the type keyword token ("class", "struct", "interface", "record").</summary>
            </PropertyComment>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;">
            <PropertyComment>
                <summary>Gets the type constraint list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;">
            <PropertyComment>
                <summary>Gets the member declarations.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>
    <Node Name="ClassDeclarationSyntax" Base="TypeDeclarationSyntax" SkipConvenienceFactories="true">
        <TypeComment>
            <summary>Class type declaration syntax.</summary>
        </TypeComment>
        <Kind Name="ClassDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Keyword" Type="SyntaxToken" Override="true">
            <PropertyComment>
                <summary>Gets the class keyword token.</summary>
            </PropertyComment>
            <Kind Name="ClassKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" Override="true">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true" Override="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true" Override="true" />
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true" Override="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;" Override="true"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;" Override="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true" Override="true">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="StructDeclarationSyntax" Base="TypeDeclarationSyntax" SkipConvenienceFactories="true">
        <TypeComment>
            <summary>Struct type declaration syntax.</summary>
        </TypeComment>
        <Kind Name="StructDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Keyword" Type="SyntaxToken" Override="true">
            <PropertyComment>
                <summary>Gets the struct keyword token.</summary>
            </PropertyComment>
            <Kind Name="StructKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" Override="true">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true" Override="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true" Override="true" />
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true" Override="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;" Override="true"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;" Override="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true" Override="true">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="InterfaceDeclarationSyntax" Base="TypeDeclarationSyntax" SkipConvenienceFactories="true">
        <TypeComment>
            <summary>Interface type declaration syntax.</summary>
        </TypeComment>
        <Kind Name="InterfaceDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Keyword" Type="SyntaxToken" Override="true">
            <PropertyComment>
                <summary>Gets the interface keyword token.</summary>
            </PropertyComment>
            <Kind Name="InterfaceKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" Override="true">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true" Override="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true" Override="true" />
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true" Override="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;" Override="true"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;" Override="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true" Override="true">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="RecordDeclarationSyntax" Base="TypeDeclarationSyntax">
        <Kind Name="RecordDeclaration" />
        <Kind Name="RecordStructDeclaration" />
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Keyword" Type="SyntaxToken" Override="true">
            <ContextualKind Name="RecordKeyword"/>
        </Field>
        <Field Name="ClassOrStructKeyword" Type="SyntaxToken" Optional="true">
            <Kind Name="ClassKeyword"/>
            <Kind Name="StructKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" Override="true">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true" Override="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Optional="true" Override="true" />
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true" Override="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;" Override="true"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Members" Type="SyntaxList&lt;MemberDeclarationSyntax&gt;" Override="true"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true" Override="true">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="EnumDeclarationSyntax" Base="BaseTypeDeclarationSyntax" SkipConvenienceFactories="true">
        <TypeComment>
            <summary>Enum type declaration syntax.</summary>
        </TypeComment>
        <Kind Name="EnumDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="EnumKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the enum keyword token.</summary>
            </PropertyComment>
            <Kind Name="EnumKeyword"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" Override="true">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="BaseList" Type="BaseListSyntax" Optional="true" Override="true">
        </Field>
        <Field Name="OpenBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Members" Type="SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt;" AllowTrailingSeparator="true">
            <PropertyComment>
                <summary>Gets the members declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBraceToken" Type="SyntaxToken" Override="true" Optional="true">
            <Kind Name="CloseBraceToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken" Optional="true" Override="true">
            <PropertyComment>
                <summary>Gets the optional semicolon token.</summary>
            </PropertyComment>
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="DelegateDeclarationSyntax" Base="MemberDeclarationSyntax">
        <TypeComment>
            <summary>Delegate declaration syntax.</summary>
        </TypeComment>
        <Kind Name="DelegateDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="DelegateKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "delegate" keyword.</summary>
            </PropertyComment>
            <Kind Name="DelegateKeyword"/>
        </Field>
        <Field Name="ReturnType" Type="TypeSyntax">
            <PropertyComment>
                <summary>Gets the return type.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;">
            <PropertyComment>
                <summary>Gets the constraint clause list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the semicolon token.</summary>
            </PropertyComment>
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <Node Name="EnumMemberDeclarationSyntax" Base="MemberDeclarationSyntax">
        <Kind Name="EnumMemberDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="EqualsValue" Type="EqualsValueClauseSyntax" Optional="true"/>
    </Node>
    <Node Name="TypeParameterConstraintClauseSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Type parameter constraint clause.</summary>
        </TypeComment>
        <Kind Name="TypeParameterConstraintClause"/>
        <Field Name="WhereKeyword" Type="SyntaxToken">
            <Kind Name="WhereKeyword"/>
        </Field>
        <Field Name="Name" Type="IdentifierNameSyntax">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierName"/>
        </Field>
        <Field Name="ColonToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the colon token.</summary>
            </PropertyComment>
            <Kind Name="ColonToken"/>
        </Field>
        <Field Name="Constraints" Type="SeparatedSyntaxList&lt;TypeParameterConstraintSyntax&gt;" MinCount="1">
            <PropertyComment>
                <summary>Gets the constraints list.</summary>
            </PropertyComment>
        </Field>
    </Node>
    <Node Name="AllowsConstraintClauseSyntax" Base="TypeParameterConstraintSyntax">
        <TypeComment>
            <summary>The allows type parameter constraint clause.</summary>
        </TypeComment>
        <Kind Name="AllowsConstraintClause"/>
        <Field Name="AllowsKeyword" Type="SyntaxToken">
            <Kind Name="AllowsKeyword"/>
        </Field>
        <Field Name="Constraints" Type="SeparatedSyntaxList&lt;AllowsConstraintSyntax&gt;" MinCount="1">
            <PropertyComment>
                <summary>Gets the constraints list.</summary>
            </PropertyComment>
        </Field>
    </Node>
    <AbstractNode Name="AllowsConstraintSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Base type for allow constraint syntax.</summary>
        </TypeComment>
    </AbstractNode>
    <Node Name="RefStructConstraintSyntax" Base="AllowsConstraintSyntax">
        <TypeComment>
            <summary>Ref struct constraint syntax.</summary>
        </TypeComment>
        <Kind Name="RefStructConstraint"/>
        <Field Name="RefKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "ref" keyword.</summary>
            </PropertyComment>
            <Kind Name="RefKeyword"/>
        </Field>
        <Field Name="StructKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "struct" keyword.</summary>
            </PropertyComment>
            <Kind Name="StructKeyword"/>
        </Field>
    </Node>
    <Node Name="EventFieldDeclarationSyntax" Base="BaseFieldDeclarationSyntax">
        <Kind Name="EventFieldDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="EventKeyword" Type="SyntaxToken">
            <Kind Name="EventKeyword"/>
        </Field>
        <Field Name="Declaration" Type="VariableDeclarationSyntax" Override="true"/>
        <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
            <Kind Name="SemicolonToken"/>
        </Field>
    </Node>
    <AbstractNode Name="BaseMethodDeclarationSyntax" Base="MemberDeclarationSyntax">
        <TypeComment>
            <summary>Base type for method declaration syntax.</summary>
        </TypeComment>
        <Field Name="ParameterList" Type="ParameterListSyntax">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Body" Type="BlockSyntax"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax"/>
                <Field Name="SemicolonToken" Type="SyntaxToken">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </AbstractNode>
    <Node Name="MethodDeclarationSyntax" Base="BaseMethodDeclarationSyntax">
        <TypeComment>
            <summary>Method declaration syntax.</summary>
        </TypeComment>
        <Kind Name="MethodDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="ReturnType" Type="TypeSyntax">
            <PropertyComment>
                <summary>Gets the return type syntax.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="TypeParameterList" Type="TypeParameterListSyntax" Optional="true"/>
        <Field Name="ParameterList" Type="ParameterListSyntax" Override="true"/>
        <Field Name="ConstraintClauses" Type="SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;">
            <PropertyComment>
                <summary>Gets the constraint clause list.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Body" Type="BlockSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" Override="true"/>
                <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="OperatorDeclarationSyntax" Base="BaseMethodDeclarationSyntax">
        <!-- should be multiple kinds? -->
        <TypeComment>
            <summary>Operator declaration syntax.</summary>
        </TypeComment>
        <Kind Name="OperatorDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="ReturnType" Type="TypeSyntax">
            <PropertyComment>
                <summary>Gets the return type.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true"/>
        <Field Name="OperatorKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "operator" keyword.</summary>
            </PropertyComment>
            <Kind Name="OperatorKeyword"/>
        </Field>
        <Field Name="CheckedKeyword" Type="SyntaxToken" Optional="true">
            <PropertyComment>
                <summary>Gets the "checked" keyword.</summary>
            </PropertyComment>
            <Kind Name="CheckedKeyword"/>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the operator token.</summary>
            </PropertyComment>
            <Kind Name="PlusToken"/>
            <Kind Name="MinusToken"/>
            <Kind Name="ExclamationToken"/>
            <Kind Name="TildeToken"/>
            <Kind Name="PlusPlusToken"/>
            <Kind Name="MinusMinusToken"/>
            <Kind Name="AsteriskToken"/>
            <Kind Name="SlashToken"/>
            <Kind Name="PercentToken"/>
            <Kind Name="LessThanLessThanToken"/>
            <Kind Name="GreaterThanGreaterThanToken"/>
            <Kind Name="GreaterThanGreaterThanGreaterThanToken"/>
            <Kind Name="BarToken"/>
            <Kind Name="AmpersandToken"/>
            <Kind Name="CaretToken"/>
            <Kind Name="EqualsEqualsToken"/>
            <Kind Name="ExclamationEqualsToken"/>
            <Kind Name="LessThanToken"/>
            <Kind Name="LessThanEqualsToken"/>
            <Kind Name="GreaterThanToken"/>
            <Kind Name="GreaterThanEqualsToken"/>
            <Kind Name="FalseKeyword"/>
            <Kind Name="TrueKeyword"/>
            <Kind Name="IsKeyword"/>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax" Override="true"/>
        <Choice>
            <Field Name="Body" Type="BlockSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" Override="true"/>
                <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="ConversionOperatorDeclarationSyntax" Base="BaseMethodDeclarationSyntax">
        <!-- should be split into two kinds-->
        <TypeComment>
            <summary>Conversion operator declaration syntax.</summary>
        </TypeComment>
        <Kind Name="ConversionOperatorDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="ImplicitOrExplicitKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "implicit" or "explicit" token.</summary>
            </PropertyComment>
            <Kind Name="ImplicitKeyword"/>
            <Kind Name="ExplicitKeyword"/>
        </Field>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true"/>
        <Field Name="OperatorKeyword" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the "operator" token.</summary>
            </PropertyComment>
            <Kind Name="OperatorKeyword"/>
        </Field>
        <Field Name="CheckedKeyword" Type="SyntaxToken" Optional="true">
            <PropertyComment>
                <summary>Gets the "checked" keyword.</summary>
            </PropertyComment>
            <Kind Name="CheckedKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeSyntax">
            <PropertyComment>
                <summary>Gets the type.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax" Override="true"/>
        <Choice>
            <Field Name="Body" Type="BlockSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" Override="true"/>
                <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="ConstructorDeclarationSyntax" Base="BaseMethodDeclarationSyntax">
        <TypeComment>
            <summary>Constructor declaration syntax.</summary>
        </TypeComment>
        <Kind Name="ConstructorDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax" Override="true"/>
        <Field Name="Initializer" Type="ConstructorInitializerSyntax" Optional="true"/>
        <Choice>
            <Field Name="Body" Type="BlockSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" Override="true"/>
                <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="DestructorDeclarationSyntax" Base="BaseMethodDeclarationSyntax">
        <TypeComment>
            <summary>Destructor declaration syntax.</summary>
        </TypeComment>
        <Kind Name="DestructorDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="TildeToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the tilde token.</summary>
            </PropertyComment>
            <Kind Name="TildeToken"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax" Override="true"/>
        <Choice>
            <Field Name="Body" Type="BlockSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" Override="true"/>
                <Field Name="SemicolonToken" Type="SyntaxToken" Override="true">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <AbstractNode Name="BasePropertyDeclarationSyntax" Base="MemberDeclarationSyntax">
        <TypeComment>
            <summary>Base type for property declaration syntax.</summary>
        </TypeComment>
        <Field Name="Type" Type="TypeSyntax">
            <PropertyComment>
                <summary>Gets the type syntax.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true">
            <PropertyComment>
                <summary>Gets the optional explicit interface specifier.</summary>
            </PropertyComment>
        </Field>
        <Field Name="AccessorList" Type="AccessorListSyntax" Optional="true" />
    </AbstractNode>
    <Node Name="PropertyDeclarationSyntax" Base="BasePropertyDeclarationSyntax">
        <Kind Name="PropertyDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Type" Type="TypeSyntax" Override="true"/>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Choice>
            <Field Name="AccessorList" Type="AccessorListSyntax" Override="true" />
            <Sequence>
                <Choice>
                    <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax" />
                    <Field Name="Initializer" Type="EqualsValueClauseSyntax" />
                </Choice>
                <Field Name="SemicolonToken" Type="SyntaxToken">
                    <Kind Name="SemicolonToken" />
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="EventDeclarationSyntax" Base="BasePropertyDeclarationSyntax">
        <Kind Name="EventDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="EventKeyword" Type="SyntaxToken">
            <Kind Name="EventKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeSyntax" Override="true"/>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Choice>
            <Field Name="AccessorList" Type="AccessorListSyntax" Override="true"/>
            <Field Name="SemicolonToken" Type="SyntaxToken">
                <Kind Name="SemicolonToken"/>
            </Field>
        </Choice>
    </Node>
    <Node Name="IndexerDeclarationSyntax" Base="BasePropertyDeclarationSyntax">
        <Kind Name="IndexerDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Type" Type="TypeSyntax" Override="true"/>
        <Field Name="ExplicitInterfaceSpecifier" Type="ExplicitInterfaceSpecifierSyntax" Optional="true" Override="true"/>
        <Field Name="ThisKeyword" Type="SyntaxToken">
            <Kind Name="ThisKeyword"/>
        </Field>
        <Field Name="ParameterList" Type="BracketedParameterListSyntax">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="AccessorList" Type="AccessorListSyntax" Override="true"/>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax"/>
                <Field Name="SemicolonToken" Type="SyntaxToken">
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>
    <Node Name="AccessorListSyntax" Base="CSharpSyntaxNode">
        <Kind Name="AccessorList"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Accessors" Type="SyntaxList&lt;AccessorDeclarationSyntax&gt;"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
        </Field>
    </Node>
    <Node Name="AccessorDeclarationSyntax" Base="CSharpSyntaxNode">
        <Kind Name="GetAccessorDeclaration"/>
        <Kind Name="SetAccessorDeclaration"/>
        <Kind Name="InitAccessorDeclaration"/>
        <Kind Name="AddAccessorDeclaration"/>
        <Kind Name="RemoveAccessorDeclaration"/>
        <Kind Name="UnknownAccessorDeclaration"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;">
            <PropertyComment>
                <summary>Gets the modifier list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="GetKeyword"/>
            <Kind Name="SetKeyword"/>
            <Kind Name="InitKeyword"/>
            <Kind Name="AddKeyword"/>
            <Kind Name="RemoveKeyword"/>
            <Kind Name="IdentifierToken"/>
            <PropertyComment>
                <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Body" Type="BlockSyntax">
                <PropertyComment>
                    <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
                </PropertyComment>
            </Field>
            <Sequence>
                <Field Name="ExpressionBody" Type="ArrowExpressionClauseSyntax">
                    <PropertyComment>
                        <summary>Gets the optional expression body.</summary>
                    </PropertyComment>
                </Field>
                <Field Name="SemicolonToken" Type="SyntaxToken">
                    <PropertyComment>
                        <summary>Gets the optional semicolon token.</summary>
                    </PropertyComment>
                    <Kind Name="SemicolonToken"/>
                </Field>
            </Sequence>
        </Choice>
    </Node>

    <!-- Preprocessor -->
    <AbstractNode Name="DirectiveTriviaSyntax" Base="StructuredTriviaSyntax">
        <Field Name="IsActive" Type="bool"/>
        <Field Name="HashToken" Type="SyntaxToken">
            <Kind Name="HashToken" />
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken">
            <Kind Name="EndOfDirectiveToken" />
        </Field>
    </AbstractNode>
    <AbstractNode Name="BranchingDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Field Name="BranchTaken" Type="bool"/>
    </AbstractNode>
    <AbstractNode Name="ConditionalDirectiveTriviaSyntax" Base="BranchingDirectiveTriviaSyntax">
        <Field Name="Condition" Type="ExpressionSyntax"/>
        <Field Name="ConditionValue" Type="bool"/>
    </AbstractNode>
    <Node Name="IfDirectiveTriviaSyntax" Base="ConditionalDirectiveTriviaSyntax">
        <Kind Name="IfDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="IfKeyword" Type="SyntaxToken">
            <Kind Name="IfKeyword"/>
        </Field>
        <Field Name="Condition" Type="ExpressionSyntax" Override="true"/>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
        <Field Name="BranchTaken" Type="bool" Override="true"/>
        <Field Name="ConditionValue" Type="bool" Override="true"/>
    </Node>
    <Node Name="ElifDirectiveTriviaSyntax" Base="ConditionalDirectiveTriviaSyntax">
        <Kind Name="ElifDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="ElifKeyword" Type="SyntaxToken">
            <Kind Name="ElifKeyword"/>
        </Field>
        <Field Name="Condition" Type="ExpressionSyntax" Override="true"/>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
        <Field Name="BranchTaken" Type="bool" Override="true"/>
        <Field Name="ConditionValue" Type="bool" Override="true"/>
    </Node>
    <Node Name="ElseDirectiveTriviaSyntax" Base="BranchingDirectiveTriviaSyntax">
        <Kind Name="ElseDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="ElseKeyword" Type="SyntaxToken">
            <Kind Name="ElseKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
        <Field Name="BranchTaken" Type="bool" Override="true"/>
    </Node>
    <Node Name="EndIfDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="EndIfDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="EndIfKeyword" Type="SyntaxToken">
            <Kind Name="EndIfKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="RegionDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="RegionDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="RegionKeyword" Type="SyntaxToken">
            <Kind Name="RegionKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="EndRegionDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="EndRegionDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="EndRegionKeyword" Type="SyntaxToken">
            <Kind Name="EndRegionKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="ErrorDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="ErrorDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="ErrorKeyword" Type="SyntaxToken">
            <Kind Name="ErrorKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="WarningDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="WarningDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="WarningKeyword" Type="SyntaxToken">
            <Kind Name="WarningKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="BadDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="BadDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken" />
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="DefineDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="DefineDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="DefineKeyword" Type="SyntaxToken">
            <Kind Name="DefineKeyword"/>
        </Field>
        <Field Name="Name" Type="SyntaxToken">
            <!-- should be identifier -->
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="UndefDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="UndefDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="UndefKeyword" Type="SyntaxToken">
            <Kind Name="UndefKeyword"/>
        </Field>
        <Field Name="Name" Type="SyntaxToken">
            <!-- should be identifier -->
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <AbstractNode Name="LineOrSpanDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Field Name="LineKeyword" Type="SyntaxToken" />
        <Field Name="File" Type="SyntaxToken" Optional="true" />
    </AbstractNode>
    <Node Name="LineDirectiveTriviaSyntax" Base="LineOrSpanDirectiveTriviaSyntax">
        <Kind Name="LineDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="LineKeyword" Type="SyntaxToken" Override="true">
            <Kind Name="LineKeyword"/>
        </Field>
        <Field Name="Line" Type="SyntaxToken">
            <Kind Name="NumericLiteralToken"/>
            <Kind Name="DefaultKeyword"/>
            <Kind Name="HiddenKeyword"/>
        </Field>
        <Field Name="File" Type="SyntaxToken" Optional="true" Override="true">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="LineDirectivePositionSyntax" Base="CSharpSyntaxNode">
        <Kind Name="LineDirectivePosition"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Line" Type="SyntaxToken">
            <Kind Name="NumericLiteralToken"/>
        </Field>
        <Field Name="CommaToken" Type="SyntaxToken">
            <Kind Name="CommaToken"/>
        </Field>
        <Field Name="Character" Type="SyntaxToken">
            <Kind Name="NumericLiteralToken"/>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="LineSpanDirectiveTriviaSyntax" Base="LineOrSpanDirectiveTriviaSyntax">
        <Kind Name="LineSpanDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="LineKeyword" Type="SyntaxToken" Override="true">
            <Kind Name="LineKeyword"/>
        </Field>
        <Field Name="Start" Type="LineDirectivePositionSyntax" />
        <Field Name="MinusToken" Type="SyntaxToken">
            <Kind Name="MinusToken"/>
        </Field>
        <Field Name="End" Type="LineDirectivePositionSyntax" />
        <Field Name="CharacterOffset" Type="SyntaxToken"  Optional="true">
            <Kind Name="NumericLiteralToken"/>
        </Field>
        <Field Name="File" Type="SyntaxToken" Override="true">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="PragmaWarningDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="PragmaWarningDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="PragmaKeyword" Type="SyntaxToken">
            <Kind Name="PragmaKeyword"/>
        </Field>
        <Field Name="WarningKeyword" Type="SyntaxToken">
            <Kind Name="WarningKeyword"/>
        </Field>
        <Field Name="DisableOrRestoreKeyword" Type="SyntaxToken">
            <Kind Name="DisableKeyword"/>
            <Kind Name="RestoreKeyword"/>
        </Field>
        <Field Name="ErrorCodes" Type="SeparatedSyntaxList&lt;ExpressionSyntax&gt;"/>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="PragmaChecksumDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="PragmaChecksumDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="PragmaKeyword" Type="SyntaxToken">
            <Kind Name="PragmaKeyword"/>
        </Field>
        <Field Name="ChecksumKeyword" Type="SyntaxToken">
            <Kind Name="ChecksumKeyword"/>
        </Field>
        <Field Name="File" Type="SyntaxToken">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="Guid" Type="SyntaxToken">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="Bytes" Type="SyntaxToken">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="ReferenceDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="ReferenceDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="ReferenceKeyword" Type="SyntaxToken">
            <Kind Name="ReferenceKeyword"/>
        </Field>
        <Field Name="File" Type="SyntaxToken">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="LoadDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="LoadDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="LoadKeyword" Type="SyntaxToken">
            <Kind Name="LoadKeyword"/>
        </Field>
        <Field Name="File" Type="SyntaxToken">
            <Kind Name="StringLiteralToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="ShebangDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="ShebangDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="ExclamationToken" Type="SyntaxToken">
            <Kind Name="ExclamationToken"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
    <Node Name="NullableDirectiveTriviaSyntax" Base="DirectiveTriviaSyntax">
        <Kind Name="NullableDirectiveTrivia"/>
        <Field Name="HashToken" Type="SyntaxToken" Override="true">
            <Kind Name="HashToken"/>
        </Field>
        <Field Name="NullableKeyword" Type="SyntaxToken">
            <Kind Name="NullableKeyword"/>
        </Field>
        <Field Name="SettingToken" Type="SyntaxToken">
            <Kind Name="EnableKeyword"/>
            <Kind Name="DisableKeyword"/>
            <Kind Name="RestoreKeyword"/>
        </Field>
        <Field Name="TargetToken" Type="SyntaxToken" Optional="true">
            <Kind Name="WarningsKeyword"/>
            <Kind Name="AnnotationsKeyword"/>
        </Field>
        <Field Name="EndOfDirectiveToken" Type="SyntaxToken" Override="true">
            <Kind Name="EndOfDirectiveToken"/>
        </Field>
        <Field Name="IsActive" Type="bool" Override="true"/>
    </Node>
</Tree>
